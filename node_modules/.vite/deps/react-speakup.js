import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/react-speakup/dist/esm/hooks/useVoiceToText.js
var import_react = __toESM(require_react());
var useVoiceToText = function(_a) {
  var _b = _a === void 0 ? { lang: "en-US", continuous: true } : _a, lang = _b.lang, continuous = _b.continuous;
  var _c = (0, import_react.useState)(""), transcript = _c[0], setTranscript = _c[1];
  var isContinuous = (0, import_react.useRef)(continuous !== null && continuous !== void 0 ? continuous : true);
  var SpeechRecognition = (0, import_react.useMemo)(function() {
    if (typeof window === "undefined") {
      return null;
    }
    return window.SpeechRecognition || window.webkitSpeechRecognition;
  }, []);
  var recognition = (0, import_react.useMemo)(function() {
    if (SpeechRecognition)
      return new SpeechRecognition();
    else
      return null;
  }, [SpeechRecognition]);
  (0, import_react.useEffect)(function() {
    if (lang && recognition) {
      recognition.lang = lang;
    }
  }, [lang, recognition]);
  function startListening() {
    if (!recognition)
      return;
    recognition.start();
    if (continuous) {
      isContinuous.current = true;
    }
  }
  function stopListening() {
    if (!recognition)
      return;
    recognition.stop();
    isContinuous.current = false;
  }
  if (recognition) {
    recognition.onend = function() {
      if (isContinuous.current) {
        startListening();
      }
    };
    recognition.onerror = function(event) {
      console.error("Speech recognition error detected: ".concat(event.error));
    };
    recognition.onresult = function(event) {
      setTranscript(function(prevTranscript) {
        return prevTranscript + " " + event.results[0][0].transcript;
      });
    };
  }
  return { startListening, stopListening, transcript };
};
var useVoiceToText_default = useVoiceToText;

// node_modules/react-speakup/dist/esm/hooks/useTextToVoice.js
var import_react2 = __toESM(require_react());
var NODE_TYPE;
(function(NODE_TYPE2) {
  NODE_TYPE2[NODE_TYPE2["ELEMENT"] = 1] = "ELEMENT";
  NODE_TYPE2[NODE_TYPE2["TEXT"] = 3] = "TEXT";
})(NODE_TYPE || (NODE_TYPE = {}));
var useTextToVoice = function(_a) {
  var _b = _a === void 0 ? {} : _a, pitch = _b.pitch, rate = _b.rate, volume = _b.volume;
  var textContainerRef = (0, import_react2.useRef)(null);
  var voiceTranscript = (0, import_react2.useRef)("");
  var firstRenderRef = (0, import_react2.useRef)(true);
  var _c = (0, import_react2.useState)(""), textContent = _c[0], setTextContent = _c[1];
  var _d = (0, import_react2.useState)(false), isSpeaking = _d[0], setIsSpeaking = _d[1];
  var synth = typeof window === "undefined" ? null : window.speechSynthesis;
  var utterThis = (0, import_react2.useMemo)(function() {
    if (typeof SpeechSynthesisUtterance === "undefined") {
      return null;
    }
    return new SpeechSynthesisUtterance(textContent);
  }, [textContent]);
  var extractText = (0, import_react2.useCallback)(function(element) {
    if (!element)
      return;
    if (element.childNodes.length > 0) {
      element.childNodes.forEach(function(child) {
        if (child.nodeType === NODE_TYPE.TEXT) {
          voiceTranscript.current += child.textContent;
        } else if (child.nodeType === NODE_TYPE.ELEMENT) {
          extractText(child);
        }
      });
    }
  }, []);
  if (utterThis) {
    utterThis.onerror = function(event) {
      console.log("An error has occurred with the speech synthesis: ".concat(event.error));
    };
    utterThis.onend = function() {
      setIsSpeaking(false);
    };
  }
  var voices = (synth === null || synth === void 0 ? void 0 : synth.getVoices()) || [];
  var voiceNames = (0, import_react2.useMemo)(function() {
    return voices.map(function(voice) {
      return voice.name;
    });
  }, [voices]);
  (0, import_react2.useEffect)(function() {
    if (firstRenderRef.current && textContainerRef) {
      var voiceContainer = textContainerRef.current;
      firstRenderRef.current = false;
      extractText(voiceContainer);
    }
    setTextContent(voiceTranscript.current);
  }, [extractText, textContainerRef]);
  (0, import_react2.useEffect)(function() {
    if (pitch && utterThis) {
      utterThis.pitch = pitch;
    }
    if (volume && utterThis) {
      utterThis.volume = volume;
    }
    if (rate && utterThis) {
      utterThis.rate = rate;
    }
  }, [utterThis, pitch, volume, rate]);
  function speak() {
    if (synth && utterThis) {
      synth.speak(utterThis);
      setIsSpeaking(true);
    }
  }
  function pause() {
    if (synth) {
      synth.pause();
      setIsSpeaking(false);
    }
  }
  function resume() {
    if (synth) {
      synth.resume();
      setIsSpeaking(true);
    }
  }
  function setVoice(voiceName) {
    if (utterThis)
      utterThis.voice = voices.find(function(item) {
        return item.name === voiceName;
      });
  }
  return {
    speak,
    pause,
    resume,
    voices: voiceNames,
    setVoice,
    ref: textContainerRef,
    utterance: utterThis,
    isSpeaking
  };
};
var useTextToVoice_default = useTextToVoice;
export {
  useTextToVoice_default as useTextToVoice,
  useVoiceToText_default as useVoiceToText
};
//# sourceMappingURL=react-speakup.js.map
